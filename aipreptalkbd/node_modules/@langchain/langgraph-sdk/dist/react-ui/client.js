import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useStream } from "../react/index.js";
import * as React from "react";
import * as ReactDOM from "react-dom";
import * as JsxRuntime from "react/jsx-runtime";
const UseStreamContext = React.createContext(null);
export function useStreamContext() {
    const ctx = React.useContext(UseStreamContext);
    if (!ctx) {
        throw new Error("useStreamContext must be used within a LoadExternalComponent");
    }
    return new Proxy(ctx, {
        get(target, prop) {
            if (prop === "meta")
                return target.meta;
            return target.stream[prop];
        },
    });
}
class ComponentStore {
    constructor() {
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "boundCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    respond(shadowRootId, comp, targetElement) {
        this.cache[shadowRootId] = { comp, target: targetElement };
        this.callbacks[shadowRootId]?.forEach((c) => c(comp, targetElement));
    }
    getBoundStore(shadowRootId) {
        this.boundCache[shadowRootId] ??= {
            subscribe: (onStoreChange) => {
                this.callbacks[shadowRootId] ??= [];
                this.callbacks[shadowRootId].push(onStoreChange);
                return () => {
                    this.callbacks[shadowRootId] = this.callbacks[shadowRootId].filter((c) => c !== onStoreChange);
                };
            },
            getSnapshot: () => this.cache[shadowRootId],
        };
        return this.boundCache[shadowRootId];
    }
}
const COMPONENT_STORE = new ComponentStore();
const COMPONENT_PROMISE_CACHE = {};
const EXT_STORE_SYMBOL = Symbol.for("LGUI_EXT_STORE");
const REQUIRE_SYMBOL = Symbol.for("LGUI_REQUIRE");
function fetchComponent(apiUrl, assistantId, agentName) {
    const cacheKey = `${apiUrl}-${assistantId}-${agentName}`;
    if (COMPONENT_PROMISE_CACHE[cacheKey] != null) {
        return COMPONENT_PROMISE_CACHE[cacheKey];
    }
    const request = fetch(`${apiUrl}/ui/${assistantId}`, {
        headers: { Accept: "text/html", "Content-Type": "application/json" },
        method: "POST",
        body: JSON.stringify({ name: agentName }),
    }).then((a) => a.text());
    COMPONENT_PROMISE_CACHE[cacheKey] = request;
    return request;
}
export function LoadExternalComponent({ apiUrl = "http://localhost:2024", assistantId, stream, message, meta, fallback, components, ...props }) {
    const ref = React.useRef(null);
    const id = React.useId();
    const shadowRootId = `child-shadow-${id}`;
    const store = React.useMemo(() => COMPONENT_STORE.getBoundStore(shadowRootId), [shadowRootId]);
    const state = React.useSyncExternalStore(store.subscribe, store.getSnapshot);
    const clientComponent = components?.[message.name];
    const hasClientComponent = clientComponent != null;
    React.useEffect(() => {
        if (hasClientComponent)
            return;
        fetchComponent(apiUrl, assistantId, message.name).then((html) => {
            const dom = ref.current;
            if (!dom)
                return;
            const root = dom.shadowRoot ?? dom.attachShadow({ mode: "open" });
            const fragment = document
                .createRange()
                .createContextualFragment(html.replace("{{shadowRootId}}", shadowRootId));
            root.appendChild(fragment);
        });
    }, [apiUrl, assistantId, message.name, shadowRootId, hasClientComponent]);
    if (hasClientComponent) {
        return React.createElement(clientComponent, message.content);
    }
    return (_jsxs(_Fragment, { children: [_jsx("div", { id: shadowRootId, ref: ref, ...props }), _jsx(UseStreamContext.Provider, { value: { stream, meta }, children: state?.target != null
                    ? ReactDOM.createPortal(React.createElement(state.comp, message.content), state.target)
                    : fallback })] }));
}
export function bootstrapUiContext() {
    if (typeof window === "undefined") {
        console.warn("Attempting to bootstrap UI context outside of browser environment. " +
            "Avoid importing from `@langchain/langgraph-sdk/react-ui` in server context.");
        return;
    }
    window[EXT_STORE_SYMBOL] = COMPONENT_STORE;
    window[REQUIRE_SYMBOL] = (name) => {
        if (name === "react")
            return React;
        if (name === "react-dom")
            return ReactDOM;
        if (name === "react/jsx-runtime")
            return JsxRuntime;
        if (name === "@langchain/langgraph-sdk/react")
            return { useStream };
        if (name === "@langchain/langgraph-sdk/react-ui") {
            return {
                useStreamContext,
                LoadExternalComponent: () => {
                    throw new Error("Nesting LoadExternalComponent is not supported");
                },
            };
        }
        throw new Error(`Unknown module...: ${name}`);
    };
}
